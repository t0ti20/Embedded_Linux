- definition int x{1};
- constants constexpr int x{1}; like  `#define`
- constants constinit int x{1}; ensuring that the initialization of the variable happens during the static initialization phase, preventing potential issues with initialization order or delayed initialization.
- function overloading
- if constexpr
- if and switch with initializer
- size_t in loops
- Range Based For Loop with initializer
## References
In C++, a reference is a powerful feature that allows you to create an alias for an existing variable. This means that the reference becomes another name for the same memory location as the original variable.
Main Features:
1- Don't use dereferencing for reading and writing
2-Can't be changed to reference something else
3- Must be initialized at declaration
Example:

```Cpp
int Variable {100};
#Reference Syntax
int &Variable_Alias {Variable};
#Make Constant Alias
const int &Const_Alias {Variable};
#Modify Alias and Source
Variable_Alias=10;
#Test
cout<<Const_Alias-Variable<<&Const_Alias-&Variable;//00
cout<<endl<<Const_Alias<<Variable_Alias;//1010
######################################
#Usefil In Range Based Loop
int Array[]{1,2,3,4,5};
for(auto &Element:Array)
{
  Element+=1;
}
for(auto Element:Array)
{
  cout << Element << endl;
}
```

# Operators
## Operator Types

```CPP
# Arithmetic Operators
a + b;
# Assignment Operators
a = 5;
# Relational Operators
a > b;
# Logical Operators
(a>b)&&(a>10);
# Bitwise Operators
a&1;
# Other Operators
sizeof
?:
&
.
->
>>
<<
```
## Operator Overloading

```CPP
void operator+(uint32_t &Number,const string &Name)
{
    for(size_t Counter{};Counter<Name.size();Counter++)
    {
        Number=Number*10+(Name[Counter]-'a');
    }
}
int main (int argc,char *argv[])
{
    uint32_t Number{};
    string Name{"abcdefg"};
    Number+Name;
    cout<<Number<<endl;
    return 0;
}
```
# Strings (std::string)
## Declaring and Using 

```cpp
#include<string>
//Empty String
std::string Name;
//Initialized
std::string Name{"My Name"};
//Part Of Strring
std::string Name{"My Name",4};
//Repeat Character
std::string Name{'A',4}
//Range
std::string Name{"Hello World",2,6};
```

## Concatenating

```cpp
#include<string>
std::string Name_1{"My Name"};
std::string Name_2{" Is Khaled"};
// + Operator
std::string Name{Name_1+Name_2};
//Append
Name_1.append(Name_2);
```

## Accessing Characters

```cpp
#include<string>
std::string Name{"This Is My String."};
// size Function
for(size_t Counter{};Counter<Name.size();Counter++)
{
	std::cout<<Name[Counter]<<std::endl;//Name.at(Counter)
}
// front and back
 char &Front=Name.front();
 char &Back=Name.back();
 Front='t';
 Back='!';
 cout<<Name<<endl;
 // Pointer
 std::string Name{"This Is My String."};
 char *Name_Ptr=Name.data();
 cout<<Name_Ptr<<endl;
```

## Size and Capacity

```cpp
#include<string>
std::string Name{"This Is My String."};
std::string No_Name{};
// empty Function
cout<<Name.empty()<<endl;
cout<<No_Name.empty()<<endl;
// size function
cout<<No_Name.size()<<endl;
cout<<Name.size()<<endl;
// length function
cout<<No_Name.length()<<endl;
cout<<Name.length()<<endl;
// max number
cout<<std::string::max_size()<<endl;
cout<<std::Name.capacity()<<endl;
// extend size
Name.reserve(<bytes>);
// reduce string
Name.shrink_to_fit(<bytes>);
```

## Modifying

```cpp
#include<string>
std::string Name{"This Is My String."};
// insert string
Name.insert(4," Hello");
Name.insert(4,1,'H');
Name.insert(4," Hello World",6);
// erase string
Name.erase(4,Name.size());
// empty string
Name.clear();
std::cout<<Name<<std::endl;
// push - pop
Name.push_back('!');
Name.pop_back();
```
## Comparing

```cpp
#include<string>
std::string Number_1{"Number 1"};
std::string Number_2{"Number 2"};
// operator
if(Number_1>Number_2)cout<<"True"<<endl;
else cout<<"False"<<endl;
// compare
if(Number_1.compare(0,6,Number_2,0,6)==0)cout<<"True"<<endl;
else cout<<"False"<<endl;
```

## Common Operations

```cpp
#include<string>
std::string Number{"Number 1"};
// Replacing
Number.replace(7,8,"2");
// copy
char Array[10]{};
Number.copy(Array,1,7);
cout<<Array<<endl;
// resize
Number.resize(10,'!');
Number.resize(6);
cout<<Number<<endl;
// swap
std::string Number_1{"Number 1"};
std::string Number_2{"Number 2"};
Number_1.swap(Number_2);
cout<<Number_1<<endl;
```

## Searching

```cpp
#include<string>
std::string Number{"The Number Is 1"};
// find
cout << Number.find("Is") << endl;
cout << Number.find("The",2) << endl;
```

## Numbers Transforming

```cpp
#include<string>
std::string Number_String{};
int Number{100};
// to_string
Number_String=to_string(Number);
cout << Number_String << endl;
// sto<type>
Number=stoi(Number_String);
cout << Number_String << endl;
```

## Raw String Literals

```cpp
#include<string>
std::string String
{
  R"<delimiter>(  1-Hello!
  2-Hello/
  3-Hello*
  4-Hello
  )<delimiter>"
};
cout<<String<<endl;
```



## String View

```cpp
#include<string>
std::string Name{"This Is My Name !"};
std::string_view Name_View{Name};
//remove_prefix
Name_View.remove_prefix(1);
//remove_suffix
Name_View.remove_suffix(1);
std::cout<<Name_View<<std::endl;
```





















___
# Functions
## Pass By Reference

```cpp
// & Operaot
void Modify_Number(int &Number){Number++;}
int main()
{
  int x{9};
  Modify_Number(x);
  cout << x << endl;
  return 0;
}
// Pointer
// Array
void Modify_Number(int (&Array)[4],int Size)
{
	for(size_t Counter{};Counter<Size;++Counter)
	{
		Array[Counter]++;
	}
}
int main()
{
  int x[]{10,20,30,40};
  Modify_Number(x,4);
  cout << x[1] << endl<< x[2] << endl<< x[3] << endl;
  return 0;
}
// & And Cast
void Modify_Number(const int &Number){cout << x << endl;}
int main()
{
  double x{9};
  Modify_Number(x);//Id Const Not Exist Will Fail
  return 0;
}
```
## Constrexpr

```CPP
constexpr int Power(constexpr int Number)
{
	return (Number*Number);
}
int main ()
{
	constexpr int Number = Power(2);
	std::cout<<Number<<std::endl;
	return 0;
}
```
## Consteval

```CPP
consteval int Power(int Number)
{
	return (Number*Number);
}
int main ()
{
	constexpr int Number = Power(2);
	std::cout<<Number<<std::endl;
	return 0;
}
```
## Main Arguments 

```cpp
int main (int argc,char *argv[])
{
    for(size_t Counter{};Counter<argc;++Counter)
    {
        cout<<argv[Counter]<<std::endl;
    }
    return 0;
}
```
## Return By Reference
```cpp
int &Maximun_Number(int &First_Number,int &Second_Number)
{
    return (First_Number>Second_Number)?First_Number:Second_Number;
    //static int result =(First_Number>Second_Number)?First_Number:Second_Number;
    //return result;
}
int main (int argc,char *argv[])
{

    int First_Number{10},Second_Number{20};
    int Result{Maximun_Number(First_Number,Second_Number)};
    cout<<Result<<std::endl;
    return 0;
}
```
## Function Overloading

```cpp
#include <array>
void Print_Name(string Name_1){cout<<Name_1<<endl;}
void Print_Name(string Name_1,string Name_2){cout<<Name_1<<' '<<Name_2<<endl;}
int main (int argc,char *argv[])
{
    Print_Name("Hello World");
    Print_Name("Hello","World");
    return 0;
}
```
## Optional Output

```cpp
#include <optional>
using namespace std;
int main (int argc,char *argv[])
{
    optional<int> Age{3};
    optional<string> Name{"Ahmed"};
    optional<bool> Gender{nullopt};
    cout<<(Age.has_value()?Age.value():-1)<<endl;
    cout<<static_cast<string>(Name.has_value()?Name.value():"")<<endl;
    cout<<(Gender.has_value()?Gender.value():-1)<<endl;
    return 0;
}
#--------------------------------------------------------------
optional<size_t> Get_Char(const string &Name,optional<char> Char)
{
    optional<size_t>Result{nullopt};
    char Searching_For{Char.value_or('!')};
    for(size_t Counter{};Counter<Name.size();++Counter)
    {
        if(Searching_For==Name[Counter])Result=Counter;
    }
    return Result;
}
int main (int argc,char *argv[])
{
    string Name{"Hello World!"};
    optional<size_t> Result=Get_Char(Name,'A');
    cout<<static_cast<int>(Result.has_value()?Result.value():-1)<<endl;
    return 0;
}
```
## Function Overloading

```cpp
uint32_t Max(uint32_t Number_1,double Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
uint32_t Max(double Number_2,uint32_t Number_1)
{
    return Number_1>Number_2?Number_1:Number_2;
}
int main (int argc,char *argv[])
{
    cout<<Max(10.10,9)<<endl;
    return 0;
}
```
## Lambda Function 

```cpp
int main (int argc,char *argv[])
{
    auto Function=[](uint32_t Numper_1,uint32_t Numper_2)->uint32_t
    {
        return (Numper_1+Numper_2);
    };
    cout<<Function(10,20)<<endl;
    return 0;
}
//----------------------------------------------------
uint32_t Number_1{20};
uint32_t Number_2{30};
int main (int argc,char *argv[])
{
    uint32_t Number_1{10};
    uint32_t Number_2{10};
    auto Function=[Number_1,Number_2]()->uint32_t
    {
        return (Number_1+Number_2);
    };
    cout<<Function()<<endl;
    return 0;
}
//------------------------------------------------------
// & Reference -- = Value
int main (int argc,char *argv[])
{
    uint32_t Number_1{10};
    uint32_t Number_2{10};
    auto Function=[&]()->uint32_t
    {
        ++Number_1;++Number_2;
        return (Number_1+Number_2);
    };
    cout<<Function()<<endl;
    cout<<Function()<<endl;
    return 0;
}
```
## Inline Functions

```CPP
inline int Add(int Number_1,int Number_2)
{
    return (Number_1+Number_2);
}
int main (int argc,char *argv[])
{
    cout<<Add(10,20)<<endl;
    return 0;
}
```
## Function Templates

```cpp
template<typename Type> Type Greater(Type Number_1,Type Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
template<> const char* Greater<const char*>(const char* String_1,const char* String_2)
{
    return (std::strcmp(String_1,String_2)>0)?String_1:String_2;
}
template<typename Return> Return* ARRAY(size_t Size)
{
    Return* Array = new Return[Size];
    return Array;
}
###############################################
#->decltype()
template<typename Type_1,typename Type_2> auto Maximum(Type_1 Number_1,Type_2 Number_2)->decltype((Number_1>Number_2)?Number_1:Number_2);
int main()
{
    auto Return{Maximum(100,20.1)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
template<typename Type_1,typename Type_2> auto Maximum(Type_1 Number_1,Type_2 Number_2)->decltype((Number_1>Number_2)?Number_1:Number_2)
{
    return (Number_1>Number_2)?Number_1:Number_2;
}
###############################################
#decltype(auto)
template<typename Type_1,typename Type_2>
decltype(auto)Maximum(Type_1 Number_1,Type_2 Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
int main()
{
    auto Return{Maximum(100,20.1)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
###############################################
#Default Arguments
template<typename Return=double,typename Type_1,typename Type_2>
Return Maximum(Type_1 Number_1,Type_2 Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
int main()
{
    auto Return{Maximum<int>(100,20.1f)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
###############################################
#Non Type Parameters
template<int Maximum_Value,typename Return=double,typename Type_1,typename Type_2>
Return Maximum(Type_1 Number_1,Type_2 Number_2)
{
return ((Number_1>Number_2?Number_1:Number_2)>Maximum_Value)?Maximum_Value:(Number_1>Number_2?Number_1:Number_2);
}
int main()
{
    auto Return{Maximum<100,int>(99,20.1f)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
###############################################
#Lamda Function With Auto Template
int main()
{
    std::cout<<
    [] <typename Type_1,typename Type_2> (Type_1 Number_1,Type_2 Number_2)
    {
        return Number_1+Number_2;
    }(10.1,29)
    <<std::endl;
    return 0;
}
###############################################
main()
{
	std::cout << std::boolalpha;
	SHOW(std::is_integral<A>::value);
	SHOW(std::is_integral_v<E>);
	SHOW(std::is_integral_v<float>);
	SHOW(std::is_integral_v<int*>);
}
###############################################
# If Constecpr 
template<typename T>
auto get_value(T t)
{
    if constexpr ([std::is_pointer_v](std::is_pointer_v<T>)
        return *t; // deduces return type to int for T = int*
    else
        return t;  // deduces return type to int for T = int
}
```
## Concepts <mark style="background: #FF5582A6;">(C++20)</mark>

```CPP
######################################
#Default Concepts
######################################
template <typename Type>
requires std::is_floating_point_v<Type>
Type Add(Type n1,Type n2)
{
    return n1+n2;
}
######################################
template <std::integral Type>
Type Add(Type n1,Type n2)
{
    return n1+n2;
}
######################################
auto Add(std::integral auto n1,std::integral auto n2)
{
    return n1+n2;
}
######################################
int main()
{
    cout<<Add(10.10,20.1)<<endl;
    return 0;
}
######################################
#Custom Concepts
######################################
template <typename Type>
concept My_Restrictions=is_floating_point_v<Type>;
template <typename Type>
Type Add(Type n1,Type n2) requires My_Restrictions<Type>
{
    return n1+n2;
}
int main()
{
    cout<<Add(10.10,20.1)<<endl;
    return 0;
}
```
## Friend Function

```cpp
#include <iostream>
struct Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{}
private:
    double m_y{};
    double m_x{};
    friend void Print(const Point &X);
    friend void Print_y(const Point &X);//NoErrors
};
void Print(const Point &X){std::cout<<"["<<X.m_x<<","<<X.m_y<<"]"<<std::endl;}
int main()
{
    Point X{1,2};
    Print(X);
    return 0;
}
//////////////////////////////////////////////////////////
#include <iostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{}
private:
    double m_y{};
    double m_x{};
    friend class Print;
};
class Print
{
public:
    void Print_Point(const Point &X){std::cout<<"["<<X.m_x<<","<<X.m_y<<"]"<<std::endl;}
};
int main()
{
    Point X{1,2};
    Print P;
    P.Print_Point(X);
    return 0;
}
```
# Enum & Type Alias
## Enum Class

```cpp
enum class MONTH : unsigned char
{
	JAN,FEP=254,MAR,
};
int main ()
{
	unsigned int Register=3'000'000'000;
	MONTH x=MONTH::MAR;
	std::cout << static_cast<int>(x) << std::endl;
	using enum MONTH
	MONTH x=MAR;
	std::cout << static_cast<int>(x) << std::endl;
	return 0;
}
```

## Type Alias

```cpp
using Number=unsigned int;
int main ()
{
    Number x=123;
    std::cout << x << std::endl;
    return 0;
}
```

# Classes
## Constrictors

```CPP
class Point
{
	private:
		   double m_x{1};
	        double m_y{1};
	public:
		Point():m_x{2},m_y{2}{};
		double distance_to(Point &Second_Point)
		{
		  return sqrt((m_x-Second_Point.m_x)*(m_x-Second_Point.m_x)+(m_y-Second_Point.m_y)*(m_y-Second_Point.m_y));
		}
};
#Default Constractor
class Point
{
	private:
		   double m_x{1};
	        double m_y{1};
	public:
		Point()=default; //If Not Exist Error Point x();
		Point(double x,double y):m_x{x},m_y{y}{};
		double distance_to(Point &Second_Point)
		{
		  return sqrt((m_x-Second_Point.m_x)*(m_x-Second_Point.m_x)+(m_y-Second_Point.m_y)*(m_y-Second_Point.m_y));
		}
};
```
## Pointers

```cpp
#include<iostream>
constexpr const double PI{3.14};
class Cylinder
{
    private:
        double Radius{1};
        double Height{1};
    public:
        double Volume(){return Radius*Radius*PI*Height;}
};
using namespace std;
int main(int, char*[])
{
    Cylinder C1{},*P_C1=&C1,&R_C1{C1};
    cout<<C1.Volume()<<endl;
    cout<<P_C1->Volume()<<endl;
    cout<<(*P_C1).Volume()<<endl;
    cout<<R_C1.Volume()<<endl;
#Test (Valid But Cant Delete It)
    Cylinder &P_C1=*(new Cylinder{});
    cout<<P_C1.Volume()<<endl;
    //delete P_C1;
    return 0;
}
######################################################
#This Pointer
template <typename Type>
Common& operator<<(Type& Message)
{
     switch (Current_Color)
     {
          case Console_Color::Default:
               std::cout<<Message;
          break;
          case Console_Color::Yellow:
               std::cout << "\033[1;33m" << Message << "\033[0m";
          break;
          case Console_Color::Blue:
               std::cout << "\033[1;34m" << Message << "\033[0m";
          break;
          case Console_Color::Red:
               std::cout << "\033[1;31m" << Message << "\033[0m";
          break;
          case Console_Color::Green:
               std::cout << "\033[1;32m" << Message << "\033[0m";
          break;
     }
     Current_Color=Console_Color::Default;
     return *this;
}
######################################################
```
## Constant

```cpp
#include<iostream>
constexpr const double PI{3.14};
using namespace std;
class Cylinder
{
    private:
        double Radius{1};
        double Height{1};
    public:
        double Volume()const{return Radius*Radius*PI*Height;}
        Cylinder(){cout<<"Constructor"<<endl;}
        ~Cylinder(){cout<<"Distructor"<<endl;}
};
const Cylinder C1{};
void Test(Cylinder Temp)
{
    cout<<Temp.Volume()<<endl;
}
int main(int, char*[])
{
    const Cylinder &P_C1=C1;
    Cylinder C2=C1;
    cout<<C1.Volume()<<endl;
    cout<<C2.Volume()<<endl;
    Test(C1);
    return 0;
}
###########################################################
#include<iostream>
constexpr const double PI{3.14};
using namespace std;
class Cylinder
{
    private:
        mutable double Radius{1};
        mutable double Height{1};
    public:
        double Volume()const{return Radius*Radius*PI*Height;}
        double& Cylinder_Radius()const{return Radius;}
        double& Cylinder_Height()const{return Height;}
        Cylinder(){cout<<"Constructor"<<endl;}
        Cylinder(double R,double H):Height{H},Radius{R}{cout<<"Constructor"<<endl;}
        ~Cylinder(){cout<<"Destructor"<<endl;}
};
int main(int, char*[])
{
    const Cylinder C1{};
    C1.Cylinder_Radius()=2;
    cout<<C1.Volume()<<endl<<C1.Cylinder_Radius()<<endl;
    return 0;
}
```
## Struct Binding

```cpp
#include<iostream>
struct Test
{
    public:
        int x{};
        int y{};
};
int main(int, char*[])
{
    Test Test_1{10,20};
    auto [x,y]=Test_1;
    std::cout<<x<<std::endl<<y<<std::endl;//10-20
    Test_1.x=40;
    Test_1.x=50;
    std::cout<<x<<std::endl<<y<<std::endl;//10-20
    return 0;
}
```
## Explicit Constructors

```cpp
#include "Company.hpp"
using namespace Mine;
bool Compare_Square(const Square &S1,const Square &S2)
{
    return (S1.Surface()>S2.Surface())?true:false;
}
int main(int, char*[])
{
    Mine::Square S1{33},S2{22};
    std::cout<<std::boolalpha;
    std::cout<<Compare_Square(S1,S2)<<std::endl;
    std::cout<<Compare_Square(S1,30)<<std::endl;//Explicit Error
    return 0;
}
class Square
{
private:
    double Side_Length{};
public:
    explicit Square(double Square_Side_Length=10);
    double Surface() const;
};
```
## Copy Constructors

```cpp
#include <iostream>
using namespace std;
struct Person
{
    int *Age{nullptr};
    string Name{};
    Person()=default;
    Person(const string &Person_Name,int Person_Age);
    Person(const Person &Copy_Person);
    ~Person();
    void Print();
};
Person::~Person(){}
Person::Person(const string &Person_Name,int Person_Age):Name{Person_Name},Age{new int(Person_Age)}{}
Person::Person(const Person &Copy_Person):Name{Copy_Person.Name},Age{new int(* Copy_Person.Age)}{}
void Person::Print()
{
    cout<<"- My Name Is "<<Name<<" I'm "<<*Age<<" Years Old .\n";
}
int main(int, char*[])
{
    Person P1{"Ahmed",11};
    Person P2{P1};
    P1.Print();
    P2.Print();
    return 0;
}
```
## Initializer list 

```CPP
#include <initializer_list>
#include <iostream>
class Point
{
public :
    Point(std::initializer_list<double> List)
    {
        std::cout<<"Default Constructor"<<std::endl;
        for(size_t Counter{};Counter<List.size();++Counter)
        {
            std::cout<<(Counter+1)<<" - "<<List.begin()[Counter]<<std::endl;
        }
        m_x=List.begin()[0];
        m_y=List.begin()[1];
    }
    void Print(void)
    {
        std::cout<<"["<<m_x<<","<<m_y<<"]"<<std::endl;
    }
    double m_y{};
    double m_x{};
};
int main()
{
    Point X{1.1,2.2,3.3};
    X.Print();
    return 0;
}
```
## Static Members

```cpp
#include <iostream>
#include <ostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{++Counter;}
    void Print(void)const{++Counter;std::cout<<"Objects = "<<Point::Counter<<std::endl;}
    ~Point(){--Counter;}
    static size_t Counter;
private:
    double m_y{};
    double m_x{};
};
size_t Point::Counter{};
int main()
{
    Point X{1,2};
    Point X2{1,2};
    std::cout<<"Objects = "<<Point::Counter<<std::endl;
    return 0;
}
/////////////////////////////////////////////////
#include <iostream>
#include <ostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{++Counter;}
    void Print(void)const{++Counter;std::cout<<"Objects = "<<Point::Counter<<std::endl;}
    ~Point(){--Counter;}
    inline static size_t Counter{};//C++17
private:
    double m_y{};
    double m_x{};
};
int main()
{
    Point X{1,2};
    Point X2{1,2};
    std::cout<<"Objects = "<<Point::Counter<<std::endl;
    return 0;
}
```